#!/usr/bin/env python3
"""Generate supported types matrix by testing registered handlers."""

from __future__ import annotations

import sys
from pathlib import Path
from typing import Callable

# Ensure repository root is on the Python path for local execution
REPO_ROOT = Path(__file__).resolve().parent.parent
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

import datason  # noqa: F401,E402 - ensure handlers are registered
from datason.type_registry import get_type_registry  # noqa: E402

# Map registry type names to factory functions that create sample objects.
# Each factory may raise ImportError if dependency missing.


def _catboost_sample():
    import catboost  # type: ignore

    return catboost.CatBoostClassifier(iterations=1, depth=1, verbose=False)


def _keras_sample():
    import keras  # type: ignore

    return keras.Sequential()


def _optuna_sample():
    import optuna  # type: ignore

    return optuna.create_study(direction="minimize")


def _plotly_sample():
    import plotly.graph_objects as go  # type: ignore

    return go.Figure()


def _polars_sample():
    import polars as pl  # type: ignore

    return pl.DataFrame({"a": [1, 2]})


def _torch_sample():
    import torch  # type: ignore

    return torch.tensor([[1.0, 2.0], [3.0, 4.0]], requires_grad=True)


def _sklearn_sample():
    from sklearn.linear_model import LinearRegression  # type: ignore

    return LinearRegression()


TYPE_SAMPLES: dict[str, Callable[[], object]] = {
    "catboost.model": _catboost_sample,
    "keras.model": _keras_sample,
    "optuna.Study": _optuna_sample,
    "plotly.graph_objects.Figure": _plotly_sample,
    "polars.DataFrame": _polars_sample,
    "torch.Tensor": _torch_sample,
    "sklearn.base.BaseEstimator": _sklearn_sample,
}


def _parse_previous(path: Path) -> dict[str, bool]:
    """Parse previous table to detect regressions."""
    if not path.exists():
        return {}
    previous: dict[str, bool] = {}
    for line in path.read_text(encoding="utf-8").splitlines():
        if not line.startswith("|") or line.startswith("| Type"):
            continue
        parts = [p.strip() for p in line.strip().strip("|").split("|")]
        if len(parts) < 4:
            continue
        status = parts[1]
        previous[parts[0]] = status in {"✅", "Yes", "yes", "true", "True"}
    return previous


def generate_supported_types_table(doc_path: Path | None = None, fail_on_regression: bool = True) -> list[str]:
    """Generate the supported types table.

    Args:
        doc_path: Optional path to output markdown file.
        fail_on_regression: If True, raise error when a previously passing type now fails.

    Returns:
        List of regression type names (empty if none).
    """
    repo_root = Path(__file__).resolve().parent.parent
    if doc_path is None:
        doc_path = repo_root / "docs" / "supported-types.md"

    registry = get_type_registry()
    type_names = sorted(registry.get_registered_types())
    previous = _parse_previous(doc_path)

    lines: list[str] = []
    regressions: list[str] = []

    header = (
        "# Supported Types\n\n"
        "This file is auto-generated by `tools/gen_supported_types.py`.\n\n"
        "| Type | Round-trip? | Notes/Caveats | Test ID |\n"
        "| --- | --- | --- | --- |\n"
    )

    for idx, type_name in enumerate(type_names, 1):
        handler = registry.find_handler_by_type_name(type_name)
        factory = TYPE_SAMPLES.get(type_name)
        note = ""
        success: bool | None
        if factory is None:
            success = None
            note = "No sample available"
        else:
            try:
                obj = factory()
            except Exception as exc:  # ImportError or others
                success = None
                note = f"Dependency not installed: {exc.__class__.__name__}"
            else:
                try:
                    serialized = handler.serialize(obj) if handler else None
                    deserialized = handler.deserialize(serialized) if handler else None
                    success = handler is not None and isinstance(deserialized, obj.__class__)
                    if not success:
                        note = f"Deserialized as {type(deserialized).__name__ if deserialized is not None else 'None'}"
                except Exception as exc:  # pragma: no cover - unexpected
                    success = False
                    note = str(exc)
        status = "✅" if success else ("❌" if success is False else "⚠️")
        test_id = f"T{idx:03d}"
        lines.append(f"| {type_name} | {status} | {note} | {test_id} |")
        # Only treat as regression on explicit failure. Missing deps (None)
        # are not counted as regressions to avoid CI false positives.
        if previous.get(type_name) and success is False:
            regressions.append(type_name)

    doc_path.write_text(header + "\n".join(lines) + "\n", encoding="utf-8")

    if fail_on_regression and regressions:
        raise RuntimeError("Round-trip regression for: " + ", ".join(regressions))
    return regressions


def main() -> None:
    """CLI entrypoint."""
    generate_supported_types_table()


if __name__ == "__main__":  # pragma: no cover
    main()
